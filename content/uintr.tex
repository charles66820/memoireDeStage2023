\section{Exploration des interruptions en espace utilisateur.}
\label{sec:exploreUintr}

Pour cette partie, j'ai utilisé mes connaissances personnelles autour du système, du développement noyau, de Linux, ainsi que ce que j'ai appris en cours de \emph{programmation système}, de \emph{système d'exploitation} et d'\emph{architecture des ordinateurs}.

\subsection{Prérequis et accès}
\label{requirements}

Pour utiliser le mécanisme d'interruption en espace utilisateur, que nous allons abréger en \uintr{} dans la suite de ce document,
il est nécessaire d'avoir accès à un CPU \intel{} Sapphire Rapids.
Du fait qu'ils étaient sortis récemment, ils étaient assez difficiles d'accès.
\atos{} nous a donné accès, non sans difficulté, à une machine qui possède 2 CPU \intel{} Sapphire Rapids, lesquels sont des \intel{} Xeon\textsuperscript{\tiny{\textregistered}} Platinum 8470.
Les difficultés étaient liées à la disponibilité d'une machine, à trouver un endroit où l'installer et à s'assurer qu'elle soit connectée à un réseau accessible depuis l'Inria.
Nous avons donc obtenu un accès VPN qui utiliser l'ancien système VPN, car le nouveau ne fonctionnait pas.
Nous avons eu accès à la machine environ deux mois et demi après le début du stage.
La machine était déjà configurée avec le système d'exploitation Red Hat Enterprise Linux (RHEL) version 9.1 avec un noyau Linux version \emph{5.14.0-162.6.1}.
Elle possède également au moins une carte BIX v2 que nous n'avons pas utilisées pendant le stage. % v2 == BXI 1.3

Il faut également avoir une version patchée du noyau Linux prenant en charge le nouveau mécanisme.
Cette version patchée n'est pas encore disponible dans la branche principale du noyau.
Cependant, elle est accessible sur le GitHub d'\intel{} \cite{intelUintrLinuxKernel}.
Elle est basée sur la version \emph{6.0.0}.
Nous avons donc téléchargé cette version patchée, puis nous l'avons compilée et installée sur la machine, toutes les commandes nécessaires pour cela sont disponibles en annexe.
Lors de la compilation, il est nécessaire d'activer le support des \uintr{} (Voir la figure \ref{fig:enableFeaturesInConfigMenu} en annexe).
Il est également possible d'activer le support permettant à un thread bloqué, c'est-à-dire non ordonnancé ou dans un appel système interruptible, de recevoir une \uintr{}.

Le mécanisme utilise de nouvelles instructions, donc une version récente du compilateur \emph{GCC} est nécessaire pour compiler les programmes utilisateurs qui utiliseront les \uintr{}.
Il faut donc la version \emph{11.3.0} ou plus récente de \emph{GCC}, et sur RHEL il faut la version \emph{12.1.1} ou supérieure.
Le support n'est pas encore disponible dans d'autres compilateurs comme \emph{LLVM-Clang} ou \emph{ICC}.
Pour compiler un programme utilisateur, il faut spécifier le flag de compilation \code{-muintr} pour les fichiers qui définissent un handler d'interruption ou qui utilisent les nouvelles instructions.

\subsection{Fonctionnement des interruptions en espace utilisateur}
\label{sec:uintr}

Dans le cadre de ce stage, nous avons étudié en détail le fonctionnement des interruptions ordinaires ainsi que le fonctionnement des interruptions en espace utilisateur.
Les \uintr{} n'était pas connus des équipes \emph{Inria} et \atos{}.

\subsubsection{Les interruptions}
\label{sec:interrupts}


Pour commencer, nous allons voire le fonctionnement des interruptions matérielles.
Nous nous concentrerons sur l'envoi d'interruptions entre deux processus fixés sur deux unités de calcul.
Pour ces interruptions les CPU disposent d'une unité dédiée à leur traitement, l'\emph{APIC} pour "Advanced Programmable Interrupt Controller".
Cette \emph{APIC} permet au système d'enregistrer un handler pour chaque interruption.
Le noyau définit un tableau appelé \emph{IDT} pour "Interrupt Descriptor Table" qui contient 256 entrées, correspondant à 256 interruptions possibles.
Les indices de l'\emph{IDT} sont des valeurs comprises entre 0 et 255, que l'on appelle également \textbf{vecteur}s d'interruption.
Parmi eux, les vecteurs entre 0 et 31 sont réservés pour les exceptions et les interruptions système,
les vecteurs entre 32 et 127 sont dédiés aux interruptions liées aux périphériques,
le vecteur 128 est réservé pour les appels système,
et les vecteurs entre 129 et 255 sont destinés à des utilisations diverses.

Il est important de savoir que chaque unité de calcul (processeur logique) possède un \emph{APIC ID} physique.
Petit fun-fact : le \emph{core ID} est un sous-ensemble de l'\emph{APIC ID}.

Pour déclencher une interruption, il y a quatre possibilités :

\begin{enumerate}
  \item Une exception déclenchée par un processeur (e.g. une division par zéro, un défaut de segmentation...).
  \item Une instruction comme \code{INT80 numSysCall} pour déclencher un appel système, ou bien \code{INT3} pour définir un point d'arrêt, ou encore \code{INTO}, \code{BOUND} et \code{INT n}.
  \item Des broches du CPU dédiées à la réception d'interruptions lancées à partir d'un périphérique.
  \item Demander à l'\emph{APIC} elle-même grâce à un registre \emph{ICR} pour "Interrupt Command Register".
  Il existe un \emph{ICR} par vecteur, donc il faut écrire l'\emph{APIC ID} du destinataire dans le \emph{ICR} du vecteur que l'on veut déclencher.
  Seul le CPU et le noyau peuvent modifier les \emph{ICR}. % TODO: est peut être les périphérique non ?
\end{enumerate}

On voit bien que les \emph{IRQ} fonctionnent au niveau du noyau et du CPU.

Nous allons voir un exemple d'envoi d'\emph{IRQ} entre deux unités de calcul en cours d'exécution.
Tout d'abord, l'initialisation des \emph{IRQ} se fait au démarrage du système et consiste principalement à définir les handlers noyau dans l'\emph{IDT}.
Il faut aussi définir quel vecteur nous voulons utiliser, le code du handler noyau qui sera invoqué,
comment l'utilisateur va contacter le système et comment faire l'identification du récepteur.
Pour cela, on peut appliquer un patch au noyau ou faire un module noyau.

Dans notre exemple, nous allons supposer que nous avons déjà patché le noyau en ajoutant des appels système et que nous avons choisi un vecteur.

Nous allons maintenant voir les étapes de l'envoi d'une \emph{IRQ}, illustrées sur la figure \ref{fig:sendInt} :

\begin{enumerate}[label=\protect\circled{\arabic*}]
  \item Le récepteur fait un appel système pour indiquer au noyau comment il veut être averti d'une interruption (e.g. un descripteur de fichiers qu'il va lire, un appel système bloquant, une zone mémoire où lire, un handler utilisateur, etc.).
  \item L'émetteur peut donc avertir le noyau qu'il faut envoyer une interruption.
  Pour cela, il peut utiliser un appel système ou écrire dans un descripteur de fichiers, par exemple.
  \item Le noyau détermine l'unité de calcul où se trouve le récepteur.
  Pour cela, il peut utiliser par exemple un \emph{PID} pour "Processus ID" donné par l'émetteur ou autre.
  Ainsi, il peut déterminer l'\emph{APIC ID} de l'unité de calcul à interrompre.
  \item Le noyau écrit donc l'\emph{APIC ID} dans le \emph{ICR} d'un vecteur déterminé à l'avance.
  L'émetteur reprend alors la main après un autre changement de contexte.
  \item L'\emph{APIC} va donc interrompre le récepteur qui va alors stopper son exécution et passer dans le noyau.
  Une fois dans le noyau, le handler va se déclencher et exécuter le code prévu au préalable (écriture dans un descripteur de fichiers, écriture dans une zone mémoire, déclenchement d'un handler utilisateur, etc.).
\end{enumerate}

\begin{figure}[H]
  \includegraphics[width=\textwidth]{interruptSend}
  \caption{L'envoi d'une interruption ordinaire}
  \label{fig:sendInt}
\end{figure}

Lors du déclenchement du handler noyau, certains registres actuels sont sauvegardés,
tels que le pointeur de pile \code{RSP},
le registre d'états \code{RFLAGS},
le registre \code{CS} et le registre de pointeur d'instruction \emph{RIP}.
Cette sauvegarde est réalisée en les empilant dans une nouvelle pile.
Le vecteur de l'interruption est aussi empilé en tant que code erreur (\emph{errorCode}).

Une fois que le handler noyau a fini de s'exécuter,
il doit exécuter l'instruction \code{iret} qui a pour effet de dépiler les registres sauvegardés et de les restaurer.

Il est possible de masquer les interruptions grâce à deux instructions utilisables seulement par le noyau,
qui sont \code{cli} et \code{sti}.
Ces instructions permettent de modifier le flag \emph{IF} pour "Interrupt Flag" qui se trouve dans le registre d'états de l'unité de calcul,
\code{RFLAGS} (aussi nommé \code{EFLAGS} sur les architectures 32 bits).
La liste des instructions pour les \emph{IRQ} se trouve dans le tableau \ref{tab:interruptInstructions}.

Comme nous l'avons vu, ce mécanisme fonctionne totalement dans le noyau du système.
Dans notre exemple, il faut au minimum deux changements de contexte (context switch) pour le récepteur et l'émetteur,
et peut-être même plus si le récepteur doit déclencher un handler côté utilisateur.

% Il fau noté que les registre 32 bit commance par un E et les 64 bit par un R (ex: EIP et RIP).
% RIP is Register Instructions Pointer, RFLAGS is Register with all core FLAGS (OF, CF, IF...), RSP is Register Stack Pointer, CS is Code Section, IF is Interrupt Flag store in EFLAGS

\subsubsection{Les uintr}
\label{sec:uintrDetails}

Le mécanisme d'interruption en espace utilisateur utilise cinq nouvelles instructions qui sont listées dans le tableau suivant \ref{tab:interruptInstructions}.
Les deux premières, \code{clui} et \code{stui} qui sont analogues à \code{cli} et \code{sti},
permettent le masquage des interruptions.
En effet, tout comme les interruptions ordinaires qui ont un flag \emph{IF} pour activer ou désactiver les interruptions,
les \uintr{} ont un flag \emph{UIF} pour "User Interrupt Flag".
L'instruction suivante, \code{testui}, permet à l'utilisateur de savoir si les interruptions sont masquées ou non.
Cette instruction existe car l'utilisateur n'a pas accès directement au \emph{UIF},
contrairement aux interruptions ordinaires qui ont un accès direct à \emph{IF} puisqu'elles fonctionnent dans le noyau.

L'instruction suivante, \code{uiret}, fonctionne de manière similaire à celle des interruptions ordinaires (\code{iret}),
mais elle n'utilise pas les mêmes registres et surtout elle est utilisable en espace utilisateur.
Enfin, la dernière instruction permet d'envoyer une \uintr{} en utilisant un indice, que nous allons voir dans la section \ref{sec:exemple}.

\begin{table}[H]
  \centering
  \resizebox{\columnwidth}{!}{%
  \begin{tabular}{|m{.5\textwidth}|m{.5\textwidth}|}
    \hline
    \bf Interruption (IRQ) & \bf Interruption utilisateur (\uintr{})\\
    \hline
    cli (\textbf{CL}ear \textbf{I}F) & clui (\textbf{CL}ear \textbf{UI}F)\\
    \hline
    sti (\textbf{S}e\textbf{T} \textbf{I}F) & stui (\textbf{S}e\textbf{T} \textbf{UI}F)\\
    \hline
    & testui (Read \textbf{UI}F)\\
    \hline
    iret (\textbf{I}nterrupt \textbf{RET}urn) & uiret (\textbf{U}ser \textbf{I}nterrupt \textbf{RET}urn)\\
    \hline
    APIC pins, APIC ICR, \code{INT n}, \code{INT3}, \code{INTO}, \code{BOUND} et \code{INT80 n} & sendipi <uipi_index>\\
    \hline
    % \multicolumn{2}{|c|}{...} \\
    % \hline
  \end{tabular}%
  }
  \caption{Instructions des interruptions et des interruptions en espace utilisateur}
  \label{tab:interruptInstructions}
\end{table}

Le mécanisme est également accompagné de six nouveaux \emph{registres d'états}, appelés registres \emph{MSR} pour "Model-Specific Registers".
Ces registres sont modifiés par le noyau grâce à des appels système que l'utilisateur effectue pour initialiser les \uintr{} et sont utilisés par le CPU.
Le tableau \ref{tab:uintrStateRegisters} décrit ces registres, et nous expliquerons leur utilité par la suite.

\begin{table}[H]
  \centering
  \resizebox{\columnwidth}{!}{%
  \begin{tabular}{|p{.45\textwidth}|p{.55\textwidth}|}
    \hline
    \bf Nom du registre & \bf Description\\
    \hline
    IA32_UINTR_STACKADJUST & Utilisé par le récepteur pour définir l'adresse de la pile alternative\\ % remplacé "définir" par "que l'unité de calcule connaisse"
    \hline
    IA32_UINTR_HANDLER & Utilisé par le récepteur pour définir l'adresse du handler \uintr{}\\
    \hline
    IA32_UINTR_MISC & Utilisé par l'émetteur pour définir la taille du \emph{UITT} et
    par le récepteur pour que l'\emph{APIC} connaisse le vecteur d'interruption ordinaire
    qu'il dois reconnaître pour déclencher le handler \uintr{}
    et le dernier bit, pour le flag de masquage \emph{UIF}\\
    \hline
    IA32_UINTR_PD & Utilisé par le récepteur pour définir l'adresse du \emph{UPID}\\
    \hline
    IA32_UINTR_RR & Utilisé par l'\emph{APIC} pour \textit{lister} les vecteurs \uintr{} qu'il doit envoyer au récepteur.
    Correspond aux derniers 64 bits du \emph{UPID}\\
    \hline
    IA32_UINTR_TT & Utilisé par l'émetteur pour définir l'adresse du \emph{UITT}\\
    \hline
    % \multicolumn{2}{|c|}{...} \\
    % \hline
  \end{tabular}%
  }
  \caption{Liste des six registres d'états des \uintr{}}
  \label{tab:uintrStateRegisters}
\end{table}

% interrupt invoked (push oldRSP, RFLAGS, CS, RIP, errorCode (IRQ vector value ?))
% IRET (pop errorCode, RIP, CS, RFLAGS, oldRSP)
% uintr invoked (push oldRSP, RFLAGS, RIP, UIRRV)
% uiret (pop UIRRV, RIP, RFLAGS, oldRSP)

\subsubsection{Capacités présentes et futures}

Le mécanisme d'interruption en espace utilisateur a une interface pour l'utilisateur similaire aux signaux \ref{sec:signal}.
Nous allons donc voir les capacités des \uintr{} en les comparant à celles des signaux.
Tout d'abord, le fonctionnement des \uintr{} se fait au niveau des threads,
tandis que celui des signaux se fait au niveau du processus.
Il est possible d'avoir un fonctionnement qui se rapproche d'un fonctionnement par threads en utilisant plusieurs options.

Avec les \uintr{}, il est possible de définir un handler différent pour chaque thread d'un processus,
alors que pour les signaux, on peut définir un seul handler pour tous les threads d'un processus.
Par contre, avec les signaux, il est possible de définir un handler différent pour chaque signal,
ce qui n'est pas possible avec les \uintr{}.
Pour les \uintr{}, il faut gérer cette différenciation manuellement en appelant la fonction correspondant au vecteur reçu.
%(le vecteur c'est une valeur qui est similaire au numéro de signal)

Il existe 64 signaux possibles, parmi lesquels les 32 premiers ont une signification particulière.
En revanche, pour les \uintr{}, il existe également 64 vecteurs possibles, entre 0 à 63, qui n'ont aucune signification particulière par défaut.

Pour les \uintr{}, le masquage se fait via une instruction, tandis que pour les signaux, il faut effectuer un appel système pour les masquer.

L'envoi d'un signal se fait par le noyau suite à une exception, une décision du noyau ou la demande d'un processus grâce à un appel système (\code{kill(signum)} ou \code{tgkill(signum)}).
Pour les \uintr{}, l'envoi peut se faire depuis un autre processus ou depuis le noyau, et dans le futur, il pourra également se faire depuis un périphérique.

Avec les signaux, le handler peut être déclenché que le processus cible soit endormi ou non, tandis que pour les \uintr{}, c'est différent.
Il faut que le thread soit en espace utilisateur pour recevoir une interruption.
Sinon, l'interruption sera reçue quand le thread revient en espace utilisateur.
On a vu précédemment, dans les prérequis, section \ref{requirements}, qu'une fonctionnalité existe lors de la compilation du noyau pour autoriser l'interruption d'un thread bloqué.
Si la fonctionnalité est activée, il est donc possible d'interrompre un thread qui n'est pas ordonnancé ou qui est en train de faire un appel système interruptible,
et ainsi le passer en espace utilisateur pour qu'il puisse recevoir l'interruption. % tâche interruptible c'est plus précis mais il faut le mettre dans le contexte
Pour utiliser cette fonctionnalité, l'utilisateur doit renseigner un flag au moment de définir le handler.

Il existe donc trois flags :
\begin{itemize}
  \item \code{UINTR_HANDLER_FLAG_WAITING_ANY} qui active la fonctionnalité,
  \item \code{UINTR_HANDLER_FLAG_WAITING_RECEIVER} et\\
  \code{UINTR_HANDLER_FLAG_WAITING_SENDER}
  qui s'ajoutent au précédent pour préciser si c'est l'émetteur ou le récepteur qui prendra en charge le surcoût du passage par le noyau.
  % on passe par le noyau mais je ne sais pas si le surcoût et lier à l’ordonnancement, au context switch, au handler noyau en plus ou tous à la fois.
\end{itemize}

Pour les signaux, le déclenchement du handler est géré par le noyau qui sauvegarde l'état du processus, définit une pile alternative si besoin, change de contexte et appelle le handler utilisateur.
Pour les \uintr{}, le déclenchement du handler est effectué par le CPU, il est donc très sommaire :
\begin{itemize}
  \item changer la pile si une pile alternative est disponible dans le registre \code{IA32_UINTR_STACKADJUST},
  \item empiler l'ancien pointeur de pile, le registre d'états de l'unité de calcul,
  le registre de pointeur d'instruction \code{RIP} et le vecteur \uintr{} % UIRRV
  \item aller à l'adresse du handler utilisateur disponible dans le registre\\
  \code{IA32_UINTR_HANDLER}.
\end{itemize}
C'est donc à l'utilisateur qu'appartient la responsabilité de sauvegarder les registres généraux,
les registres vectoriels (SIMD)... et de les restaurer à la sortie du handler.
Le compilateur permet déjà de sauvegarder les registres généraux avec le flag \code{general-regs-only}.
Cependant, pour les registres vectoriels, il faut les sauvegarder avant de les utiliser.
Il faut faire attention avec les opérations sur les chaînes de caractères de la \emph{libc} car les
fonctions \code{memcpy}, \code{memmove}, \code{memset} et \code{memcmp} utilisent des registres vectoriels par défaut.
Le compilateur fournit le flag \code{-minline-all-stringops} qui permet de les remplacer par des versions inline
de ces opérations afin de ne plus utiliser de registres vectoriels. % besoin d'expliqué l'inline ?

Une fois que le handler a fini son exécution, il faut s'occuper du retour.
Pour les signaux, c'est le noyau qui s'en occupe, tandis que pour les \uintr{},
il incombe à l'utilisateur d'utiliser l'instruction \code{uiret}.
Donc, l'unité de calcul va dépiler le vecteur et les registres qui suivent pour les restaurer, ce qui permettra au code de continuer là où il en était.

Que ce soit dans un handler de signal ou dans un handler d'interruption utilisateur, on a la même contrainte :
on ne peut pas faire d'attente, donc on peut seulement appeler des fonctions et des appels système dits "async safe".

\subsubsection{Exemple de fonctionnement}
\label{sec:exemple}

Nous allons maintenant voir un exemple d'initialisation des \uintr{} illustré sur la figure \ref{fig:initUintr} :

\begin{enumerate}[label=\protect\circled{\arabic*}]
  \item Le récepteur enregistre auprès du noyau un handler d'interruption qu'il a défini à l'aide de l'appel système\\
  \code{uintr_register_handler(ui_handler)}.
  Le noyau va enregistrer ce handler dans le registre \code{IA32_UINTR_HANDLER} et va initialiser une zone mémoire nommée \emph{UPID} pour "User Posted Interrupt Descriptor".
  Ce \emph{UPID} permet au mécanisme des \uintr{} de manipuler des informations propres à ce thread, essentielles pour l'envoi d'\uintr{}.
  L'adresse du \emph{UPID} est enregistré dans le registre \code{IA32_UINTR_PD}.
  \item Le récepteur donne au noyau un vecteur \uintr{} entre 0 et 63 qu'il souhaite recevoir (8 dans la figure),
  à l'aide de l'appel système\\
  \code{uvec_fd <- uintr_vector_fd(8)}.
  Le noyau lui renvoie un descripteur de fichier qui pointe vers une structure contenant à la fois le vecteur et l'adresse du \emph{UPID}.
  \item Le récepteur envoie ce descripteur de fichier aux émetteurs potentiels, un seul dans notre cas.
  Nous verrons comment partager ce descripteur de fichier dans la section \ref{sec:shareFD}.
  \item L'émetteur va s'enregistrer auprès du noyau grâce au descripteur de fichier en appelant l'appel système\\
  \code{uipi_index <- uintr_register_sender(uvec_fd)}.
  Pour ce faire, le noyau possède un tableau \emph{UITT} pour "User Interrupt Target Table" qui fait une taille de 256 entrées par défaut.
  L'adresse de ce tableau doit être enregistrée dans le registre \code{IA32_UINTR_TT},
  et sa taille doit être placée dans les quatre premiers octets du registre \code{IA32_UINTR_MISC}.
  Ainsi, la taille du \emph{UITT} peut varier en fonction des besoins.
  Chaque entrée de ce tableau \emph{UITT} correspond à une zone mémoire nommée \emph{UITTE} pour "User Interrupt Target Table Entry".
  Le noyau va rechercher une entrée libre dans le \emph{UITT} et remplir l'\emph{UITTE} avec le vecteur \uintr{} et
  l'adresse du \emph{UPID} obtenus grâce au descripteur de fichier.
  Il va également mettre un vecteur d'interruption ordinaire dans le cinquième octet du registre \code{IA32_UINTR_MISC},
  ce vecteur "ordinaire" étant dédié aux \uintr{} et a pour valeur 236.
  Pour finir il retourne l'indice de l'entré à l'émetteur.
  \item L'utilisateur peut maintenant envoyer autant d'interruptions que nécessaire, totalement depuis l'espace utilisateur.
\end{enumerate}

\begin{figure}[H]
  \includegraphics[width=\textwidth]{uintrInit}
  \caption{Phase d'initialisation des uintr}
  \label{fig:initUintr}
\end{figure}

Maintenant que nous avons vu l'initialisation, nous allons pouvoir voir comment l'envoi d'interruption est réalisé, comme illustré dans la figure \ref{fig:sendUintr} :

\begin{enumerate}[label=\protect\circled{\arabic*}]
  \item L'émetteur utilise l'instruction \code{senduipi} avec l'indice récupéré lors de l'initialisation.
  L'unité de calcul peut accéder au tableau \emph{UITT} qui se trouve dans le registre \code{IA32_UINTR_TT}.
  Elle peut vérifie que l'indice se trouve bien dans le tableau, en utilisant la taille qui se trouve dans le registre \code{IA32_UINTR_MISC}.
  De plus, il s'assure que l'entrée dans le \emph{UITT} est valide.
  À partir de l'indice donné à l'instruction, l'émetteur peut récupérer l'adresse de l'\emph{UPID} et le vecteur \uintr{} à envoyer au récepteur.
  Dans la zone mémoire de l'\emph{UPID}, il écrit le vecteur \uintr{} à envoyer et détermine s'il faut également envoyer une interruption ordinaire.
  En effet, les interruptions en espace utilisateur utilisent les interruptions ordinaires,
  et l'envoi de celles-ci dépend de si une interruption ordinaire n'a pas déjà été envoyée.
  Dans notre cas, nous considérons que c'est le premier envoi.
  \item Donc, l'émetteur va récupérer le vecteur d'interruption ordinaire dans le registre \code{IA32_UINTR_MISC} et
  sélectionner le registre \emph{ICR} correspondant au vecteur "ordinaire".
  Ensuite, il va récupérer l'\emph{APIC ID} dans l'\emph{UPID} et l'écrire dans le registre \emph{ICR}.
  Cela permettra d'envoyer l'interruption ordinaire à l'unité de calcul correspondante.
  \item L'\emph{APIC} va recevoir l'interruption, puis elle va comparer le vecteur d'interruption ordinaire reçu avec celui qui se trouve dans l'\emph{UPID}, qu'il connaît grâce au registre \code{IA32_UINTR_PD}.
  Si les vecteurs sont identiques, l'\emph{APIC} va pouvoir déclencher le système de traitement des \uintr{}, sinon, elle va utiliser le mécanisme habituel des \emph{IRQ}.

  \item Le système de traitement des \uintr{} va donc indiquer dans l'\emph{UPID} que l'interruption ordinaire a déjà été envoyée,
  puis va commencer le déclenchement des handlers pour tous les vecteurs \uintr{} reçus, en partant du plus grand, 63, jusqu'au plus petit, 0.
  \code{IA32_UINTR_RR} est utilisé à cette étape.
  Dans notre exemple, nous en avons un seul qui est 8.
  L'\emph{APIC} va donc ordonner à l'unité de calcul de changer de pile si une pile alternative est disponible dans
  le registre \code{IA32_UINTR_STACKADJUST}, empiler les registres nécessaires, empiler le vecteur \uintr{} (donc 8 dans l'exemple) et aller à l'adresse du handler qui est disponible dans le registre \code{IA32_UINTR_HANDLER}.
\end{enumerate}

\begin{figure}[H]
  \includegraphics[width=\textwidth]{uintrSend}
  \caption{L'envoi d'une \uintr{}}
  \label{fig:sendUintr}
\end{figure}

Le mécanisme habituel des \emph{IRQ} peut être utilisé dans le cas où l'\uintr{} est déclenchée depuis le noyau et
dans le cas où le thread destinataire n'est pas ordonnancé ou est dans un appel système interruptible.

\subsubsection{Partage du descripteur de fichier}
\label{sec:shareFD}

Pour partager le descripteur de fichier, il y a plusieurs façons possibles.

Dans nos tests du mécanisme entre processus, nous avons utilisé l'héritage des descripteurs de fichier.
Dans nos tests du mécanisme entre threads, nous avons utilisé un appel système qui permet d'enregistrer tous les threads du processus comme émetteurs, sans utiliser le descripteur de fichier, % \verb|uintr_register_self()|
mais il est possible d'utiliser une variable globale pour y mettre le descripteur de fichier.

Dans le cas où les deux processus sont indépendants, on peut utiliser l'appel système \code{pidfd_getfd} qui permet de dupliquer le descripteur de fichier d'un autre processus s'il a le même propriétaire et si l'on connaît son \emph{PID} et le numéro du descripteur de fichier.
Nous avons donc testé en partageant le numéro de descripteur de fichier avec un pipe.
On aurait aussi pu passer par un fichier ou par des sockets.

Par la suite, dans \emph{NewMadeleine}, nous avons utilisé le système d'URL à la connexion que nous verrons dans la section /* TODO: ref */.

\subsection{Tests du mécanisme}

Nous avons donc effectué des tests du mécanisme avec des exemples minimaux de communication entre processus.
Nous examinerons les plus pertinents dans cette section.

Tout d'abord, des tests pour mesurer le temps d'envoi d'interruption en espace utilisateur entre deux threads et deux processus.

Pour le test d'envoi entre deux threads, il commence par créer un nouveau thread qui va commencer par se "bind" à une unité de calcul.
Nous le verrons en détail dans la section \ref{sec:latencyMesure}.

Il va ensuite enregistrer un handler d'interruption, démasquer les interruptions, enregistrer tous les threads du processus comme émetteurs avec l'appel système \code{uipi_index <- uintr_register_self(vector)},\\
(uipi_index est global au processus) et attendre grâce à une boucle.

Pendant ce temps-là, le thread principal attend une seconde.
Ce temps est arbitraire et laisse le temps au thread d'enregistrer un handler d'interruption.
Après son attente, il va se "bind" à une unité de calcul puis envoyer une interruption.
Pour cela, nous commençons par enregistrer le temps processeur actuel, puis nous utilisons l'instruction \code{senduipi} avec la variable globale \code{uipi_index}.
Une fois que le handler d'interruption se déclenche, on enregistre le temps actuel du processeur pour ensuite calculer la différence.
Ce test est capable de faire cette mesure plusieurs fois.
Il finit par imprimer les différences de temps dans la console et par désallouer et de-enregistrer les \uintr{} et les autres structures.

Pour le teste d'envoi entre deux processus, il commence par créer un pipe pour l'envoi du descripteur de fichier et une zone de mémoire partagée pour stocker les mesures de temps.
Puis le processus se fork en deux, le premier devient l'émetteur et le second le récepteur.
Comme pour la version avec threads, ils se "bind" à une unité de calcul.
Le récepteur enregistre un handler d'interruption et récupère un descripteur de fichier avec l'appel système \code{uvec_fd <- uintr_vector_fd(vector)} qu'il envoie dans le pipe avant d'attendre grâce à une boucle.
L'émetteur reçoit le numéro du descripteur de fichier, il connaît déjà le \emph{PID} du processus grâce au fork,
il peut donc utiliser \code{pidfd_getfd} pour dupliquer le descripteur de fichier.
Avec ce descripteur, il s'enregistre en tant qu'émetteur d'uintr.
La mesure du temps et l'envoi d'interruption fonctionnent de la même manière que pour la version avec threads.
On peut aussi effectuer la mesure plusieurs fois et on imprime et termine proprement.

On verra les résultats de ces mesures dans la section \ref{sec:performance}.

Un test où le thread s'auto-interrompt tout simplement en faisant un \code{uipi_index <- uintr_register_self(vector)},\\
puis un \code{senduipi uipi_index}, et on fait la mesure de la même façon que pour les autres tests.

Pour les tests avec la pile alternative, nous avons un test très simple qui est basé sur celui qui s'auto-interrompt, et nous modifions les tests d'envoi entre deux processus ou threads pour mesurer l'impact les performances.
Il est bien sûr possible d'activer ou non l'utilisation de la pile alternative.
Pour définir cette nouvelle pile, on le fait juste après avoir enregistré le handler d'interruption et avant le démasquage.

Un test de démasquage des \uintr{} dans un handler d'interruption.
Il nous permet de voir que c'est tous à fait possible et cela pose des problématiques similaires à celles des signaux.

Un test consiste à envoyer plusieurs interruptions d'affilée.
Il nous permet de voir qu'il y a une différence de comportement par rapport aux signaux.
Quand on reçoit une interruption et que le handler d'interruption est déclenché, le comportement est le même,
c'est-à-dire que les interruptions vont s'écraser et le handler d'interruption se déclenchera à nouveau une fois.
La différence réside dans le fait que si l'on effectue plusieurs interruptions avant que le handler d'interruption ne se déclenche,
les interruptions s'écrasent également à ce moment-là.
Ainsi, le handler d'interruption ne se déclenchera qu'une seule fois lorsque l'on effectue deux interruptions successives.
Avec les signaux, en revanche, le handler de signal se déclencherait deux fois pour deux émissions de signal successives car le handler est déjà déclenché dès le premier signal.

Grâce à un test, nous avons constaté qu'actuellement on peut enregistrer plusieurs fois le même descripteur de fichier,
ce qui mène à des doublons dans le tableau \emph{UITT} avec plusieurs \emph{UITTE} pour le même couple vecteur / \emph{UPID}.
Cette limitation de l'implémentation noyau est documentée dans le patch et accompagnée d'un commentaire \emph{TODO}.

\subsection{Correction d'un bug dans le patch noyau}

En manipulent le mécanisme nous somme tombé sur un bug qui concerne l'utilisation d'une pile alternative.
Comme pour les signaux il est possible de définir une pile alternative, cette nouvelle pile est utiliser au moment où le handler et déclencher.
L'interface pour définir la pile alternative est la même pour les signaux et les uintr.
Dans les manuels il est bien indiquer que l'utilisateur dois lui même allouer une zone mémoire consacré à la nouvelle pile, il a également la responsabilité de libérer la mémoire une fois le handler dé-enregistrer.
Il est bien indiquer que l'utilisateur dois donné l'adresse de début (\emph{base address}) de la zone mémoire en plus la taille à l'appel système qui défini la pile alternative.
Pour les uintr l'appel système est \code{uintr_alt_stack(spAddress, size)}.
Il faut noté qu'une pile empile les éléments vers le haut c'est à dire que l'adresse du pointeur de pile décrois à l'ajout d'un éléments.
Donc pour utiliser la zone mémoire dédier à la pile à partir de la fin.
Du coté du noyau le mécanisme des signaux garde l'adresse et la taille en mémoire pour le moment ou le handler dois être déclencher.
Le calcul du pointeur de pile de la nouvelle pile ce fait donc juste avant de déclencher le handler.
Pour les uintr le noyau se contente juste d'enregistrer l'adresse dans le registre dédier \code{IA32_UINTR_STACKADJUST} et le processeur utilise l'adresse tel quel comme pointeur de pile.
On est donc confronté à un bug de débordement mémoire car on part du début de la zone mémoire.
Il y a bien un test dans le patch du noyau qui vérifie ce cas mais mal.
Nous somme tombé sur ce bug au moment d'utiliser le uintr dans \emph{NewMadeleine} qui manipulent bien plus la mémoire qu'un simple test, on ce retrouvé avec des problèmes de corruption mémoire, des défauts de segmentation et des "double free detected".
Nous avons donc corriger le test du patch noyau ainsi que l'appel système.
Pour ce fait on ajoute la taille de la zone mémoire à l'adresse avant de l'écrire dans le registre.
Nous avons donc fait une \emph{Pull request} sur le dépôt GitHub du patch, à l'heurs ou nous écrivons ce document il n'a toujours pas étais appliqué par \intel{}.

\subsection{Mesure de la latence}
\label{sec:latencyMesure}

Pour mesurer la latence entre le moment où on envois une interruption et où l'interruption est reçus par le handler on fait 2 mesure de temps.
Pour faire les mesure de temps on utilise \code{clock_gettime} qui utilise l'introduction \code{rdtsc} et retourne le temps actuelle du processeur.
On fait une premier mesure juste avant d'envoyer une interruptions et une seconde au tous début du handler.
Pour obtenir la latence on a juste à soustraire la premier mesure à la seconde.

Nous avons regarder le code assembleur pour s'assurer de la mesures.
Pour l'envoi, que l'on peut voire sur la figure \ref{fig:sendUintrAsm}, on peut voir que entre la mesure est l'instruction d'envois il y a seulement une Lecture mémoire qui n'est pas très coûteuse.
Du coté de la réception, que l'on peut voire sur la figure \ref{fig:handlerUintrAsm}, on vois la sauvegarde des registres généraux au début du handler.
Cette sauvegarde ajoute un petit surcoût mais il est obligatoire.
Le compilateur \emph{GCC} nous force à mettre le flag \code{general-regs-only} pour compiler un handler d'interruption et donc sauvegardé les registre généraux.
On peut voire la déclaration d'un handler avec la mesure du temps sur la figure \ref{fig:unitrHandler}.
\begin{figure}[H]
  \includegraphics[width=\textwidth]{senduipiTimeThreadO3}
  \caption{Code assembleur de l'envois d'uintr}
  \label{fig:sendUintrAsm}
\end{figure}

\begin{figure}[H]
  \includegraphics[height=\textwidth]{handlerTimeThreadO3}
  \caption{Code assembleur de l'handler uintr}
  \label{fig:handlerUintrAsm}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{handlerDeclaration}
  \caption{Déclaration du handler uintr}
  \label{fig:unitrHandler}
\end{figure}

Nous faisons la mesure de la même façon pour les signaux.

Pour ne pas perturber la mesure il faut "bind" les threads à une unité de calcul.
"bind" consiste à demander au noyau de toujours ordonnancer le thread sur la même unité de calcul.
Pour ce faire nous utilisons la bibliothèque \emph{hwloc}. % TODO: cite here hwloc
Il est donc important de "bind" les threads pendent les mesures car dans le cas contraire le noyau vas changer le thread d'unité de calcul ce qui vas amené à un surcoût non négligeable.
En effet le changement d'unité et un peut coûteux et invalide certain cache.

"bind" les threads nous permet aussi de contrôler le placement de ceci, c'est à dire si on met le thread émetteur et le thread récepteur sur deux unité de calcule proche ou distante.
Comme nous le verrons dans la section \ref{sec:performance} le placement a un impact sur la latence des uintr.

Il est aussi important de fixer la fréquence de tous les core du CPU pour avoir des mesure courante.

\subsection{Performances}
\label{sec:performance}

Dans cette section nous allons voir des mesure de la latence des uintr dans différant contexts.
La fréquence des unités de calcul est fixer à 2GHz lors des mesure.
Les mesure faite avec le turbo boost activé monte à 3.8GHz.
Les mesures de latence sont en nanoseconde.
Il est intéressant de noter que sur une unité de calcul cadencer à une fréquence de 2GHz elle execute environ deux instructions par nanoseconde. % plus 2 cycle
Certaine mesure, que se sois avec les uintr ou les signaux, sont très élevé mais sont très peut nombreuse, elle sont certainement lié au système.
Dans les graphiques que nous allons voir nous avons donc coupé les valeurs qui dépasse les 8000 nanoseconde.
Nous avons défini trois placements à partir le la topologie de la machine fourni par \atos{} (vous pouvez trouver la topologie sur cette figure\ref{fig:lstopo}).
Les trois placements sont les suivant :
\begin{itemize}
  \item le placements "proche" qui consiste à placer les threads sur deux unité de calcule proche mais pas dans le même core.
  \item le placements "éloigné" qui consiste à placer les threads sur deux unité de calcule qui sont dans le même CPU et qui sont éloigné.
  \item le placements "très éloigné" qui consiste à placer les threads sur deux unité de calcule qui ce trouve sur deux CPU différant.
\end{itemize}

Les mesures que nous allons présenter on étais faite sans que la pile alternative ne sois activé.
Nous avons bien fait des mesures avec la pile alternative des uintr activé est nous n'avons vue aucune différence car l'utilisation de cette pile
amené seulement à une copie de la mémoire d'un registre à un autre si le registre contiens une adresse ce qui est très peut coûteux.

Dans nos graphiques nous appelons une mesure une interaction.
Nous faisons donc un millions d'iterations et nous n'affichons pas la premier car cette itération est énormément perturber notamment par le coût de chargement des caches.

Dans les graphiques nous avons représenté la mesure de la latence par des points bleu pour les signaux et par des points rouge pour les uintr.
Nous ne cherchons pas à expliquer les mesure des signaux, elle sont juste là pour comparer les uintr avec un mécanisme qui passe par le noyau.

Sur la graphiques \ref{subfig:latency1e6ThreadsNT}, les itérations sont représenté sur l'axe des abscisses et la latence sur l'axe des ordonnés.
Bien sur plus la latence est basse mieux c'est.
Nous observons que le mécanisme a une latence de environ 642 nanoseconde ce qui est environ 4.75 fois plus rapide que les signaux.
On vois qu'il y a deux groupe de mesure :
\begin{itemize}
  \item un au alentours des 642 nanoseconde qui comporte la majorité des mesures.
  On le vois bien dans le tableau \ref{tab:latency1e6ThreadsNT} qui ce trouve juste en dessous du graphiques.
  En effet entre la mesure minimum et la mesure à 95\% il y a une différence de 19 nanoseconde.
  On peut voir cette distribution aussi dans l'histogramme sur cette figure \ref{fig:distribution}.
  Cette histogramme porte sur des plage de 300 nanoseconde.
  On vois bien pour les uintr, en orange, que la majorité ce trouve sur la bande entre 300 et 600 nanoseconde.
  \item un autre vers 2700 nanoseconde qui correspond certainement au moment ou l'interruptions n'as pas pu être reçus car le thread été dans le noyau.
\end{itemize}

Pour un mécanisme qui fonctionne au niveau des instructions on pourrais s'attendre à une latence moins grande mais le mécanisme est bien plus rapide que le fait de passé par le système.
% il serai intéressant de comparer avec la latence d'une IRQ 236 et non uintr
% TODO: ce qu'on en pense, c'est bon ?

\begin{figure}[H]
  \begin{subfigure}{\textwidth}
    \includegraphics[width=\textwidth]{latency/1e6ThreadsNT}
    \caption{}
    \label{subfig:latency1e6ThreadsNT}
  \end{subfigure}
  \begin{subtable}{\textwidth}
    \centering
    \begin{tabular}{| l | l | l | l | l | l | l | l |}
      \hline
      &\bf mean &\bf std &\bf min  &\bf 10\% &\bf 50\% &\bf 95\% &\bf max\\
      \hline
      \bf sig   & 3065 & 160 & 2920 & 3001 & 3054 & 3157 & 68532\\
      \hline
      \bf uintr & 643  & 90  & 629  & 638  & 642  & 648  & 65973\\
      \hline
    \end{tabular}
    \caption{}
    \label{tab:latency1e6ThreadsNT}
  \end{subtable}
  \caption{Mesures de latence entre deux threads avec un placement proche}
  \label{fig:latency1e6ThreadsNT}
\end{figure}

\begin{figure}[H]
  \includegraphics[width=\textwidth]{latency/distribution}
  \caption{Histogramme de distribution des mesures de la latence entre deux threads proche}
  \label{fig:distribution}
\end{figure}

Nous avons fait les même mesure entre deux processus est les valeur sont très similaire peut importe le placement car le mécanisme fonctionne au niveau des threads.
On peut retrouvé le ces mesure en annexe sur la figure \ref{fig:latency1e6ProcessNT}.

En comparant les mesures de latences entre le placement proche et éloigné on vois une petite différence de 10 nanoseconde de plus, on peut voir ça sur la figure \ref{fig:latency1e6ThreadsF}.

Quand on compare entre le placement proche et très éloigné on vois une grand différence qui est du notamment au fait de passer d'un noeud mémoire NUMA à un autre.
On à donc une différence d'environ 172 nanoseconde de plus.
Le graphiques nous montre également une plus grande dispersion de la latence avec la majorité qui est toujours en dessous de 1000 nanoseconde.
On retrouve ces mesures sur la figure \ref{fig:latency1e6ThreadsVF} juste en dessous.
\begin{figure}[H]
  \begin{subfigure}{\textwidth}
    \includegraphics[width=\textwidth]{latency/1e6ThreadsVF}
    \caption{}
    \label{subfig:latency1e6ThreadsVF}
  \end{subfigure}
  \begin{subtable}{\textwidth}
    \centering
    \begin{tabular}{| l | l | l | l | l | l | l | l |}
      \hline
      &\bf mean &\bf std &\bf min  &\bf 10\% &\bf 50\% &\bf 95\% &\bf max\\
      \hline
      \bf sig   & 4601 & 403 & 4009 & 4396 & 4561 & 4796 & 58200\\
      \hline
      \bf uintr & 818  & 136 & 801  & 810  & 814  & 820  & 58072\\
      \hline
    \end{tabular}
    \caption{}
    \label{tab:latency1e6ThreadsVF}
  \end{subtable}
  \caption{Mesures de latence entre deux threads avec un placement très éloigné}
  \label{fig:latency1e6ThreadsVF}
\end{figure}


Quand on augmente la fréquence des unités de calcul la latence diminue.
Pour ce faire on active le turbo boost du CPU.
On le vois sur les mesure de la figure \ref{fig:latency1e6ThreadsNT-TB} pour le placement proche mais c'est également le cas pour l'éloigné et le très éloigné en figure \ref{fig:latency1e6ThreadsF-TB} et figure \ref{fig:latency1e6ThreadsVF-TB}.

\begin{figure}[H]
  \begin{subfigure}{\textwidth}
    \includegraphics[width=\textwidth]{latency/1e6ThreadsNT+TB}
    \caption{}
    \label{subfig:latency1e6ThreadsNT-TB}
  \end{subfigure}
  \begin{subtable}{\textwidth}
    \centering
    \begin{tabular}{| l | l | l | l | l | l | l | l |}
      \hline
      &\bf mean &\bf std &\bf min  &\bf 10\% &\bf 50\% &\bf 95\% &\bf max\\
      \hline
      \bf sig   & 2262 & 294 & 2081 & 2216 & 2251 & 2357 & 283171\\
      \hline
      \bf uintr & 442  & 313 & 426  & 437  & 440  & 450  & 311486\\
      \hline
    \end{tabular}
    \caption{}
    \label{tab:latency1e6ThreadsNT-TB}
  \end{subtable}
  \caption{Mesures de latence entre deux threads avec un placement proche et le turbo boost activé}
  \label{fig:latency1e6ThreadsNT-TB}
\end{figure}

Nous n'avons fait aucune mesures de latence pour les threads bloqué et interruptible.
